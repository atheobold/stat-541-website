---
title: "Lab 6"
subtitle: "Performing Many Different Versions of an Analysis"
editor: source
---


My number one use case for writing functions and iteration/looping is to perform
some exploration or modeling repeatedly for different "tweaked" versions. For
example, our broad goal might be to fit a linear regression model to our data.
However, there are often multiple choices that we have to make in practice:

- Keep missing values or fill them in (imputation)? 
- Fit the model only on a certain group of cases?
- Filter out outliers in one or more variables?
- Transform certain variables? (e.g., log transformation)

We can map these choices to **arguments** in a custom model-fitting function:

- `impute`: TRUE or FALSE
- `filter_to`: This could be a set of string descriptions: 
  * "All cases", 
  * "Group 1", 
  * "Groups 1 and 2"
- `remove_outliers`: TRUE or FALSE
- `outlier_sd_thresh`: Cases that are more than this number of SDs away from the
mean will be considered outliers and excluded

The `tidyr` package has a useful function called `crossing()` that is useful for
generating argument combinations. For each argument, we specify all possible
values for that argument. `crossing()` generates all combinations.

```{r}
#| label: crossing-all-sets-of-arguments

df_arg_combos <- crossing(
    impute = c(TRUE, FALSE),
    filter_to = c("All cases", "Group 1", "Groups 1 and 2"),
    remove_outliers = c(TRUE, FALSE)
)
df_arg_combos
```

A function that implements the analysis and allows for variation in these 
choices:

```{r}
fit_model <- function(df, impute, filter_to, remove_outliers) {
    if (impute) {
        df <- some_imputation_function(df)
    }
    
    if (filter_to == "Group 1") {
        df <- df %>% 
            filter(group == 1)
    } else if (filter_to == "Groups 1 and 2") {
        df <- df %>% 
            filter(group %in% c(1, 2))
    }
    
    if (remove_outliers) {
        df <- function_for_removing_outliers(df)
    }
    
    lm(y ~ x1 + x2, data = df)
}
```

But how can we iterate the `fit_model()` function over the combinations in `df_arg_combos`? We have two good options in R:

- `for` loops
- The `purrr` package

## `for` loops

In the `diamonds` dataset, we want to understand the relationship between `price` and size (`carat`). We want to explore variation along two choices:

1. The variables included in the model. We'll explore 3 sets of variables:
    - No further variables (just `price` and `carat`)
    - Adjusting for `cut`
    - Adjusting for `cut` and `clarity`
    - Adjusting for `cut`, `clarity`, and `color`
2. Whether or not to remove outliers in the `carat` variable. We'll define outliers as cases whose `carat` is over 3 SDs away from the mean.


**Exercise 1:** Use `crossing()` to create the data frame of argument combinations for our analyses. Note that you can create a list of **formula** objects in R with `c(y ~ x1, y ~ x1 + x2)`.

<details>
  <summary>Solution</summary>
  
```{r}
df_arg_combos <- crossing(
    mod_formula = c(price ~ carat, price ~ carat + cut,  price ~ carat + cut + clarity,  price ~ carat + cut + clarity + color),
    remove_outliers = c(TRUE, FALSE)
)
df_arg_combos
```

</details>

**Exercise 2:** Write a function that removes outliers in a dataset. The user should be able to supply the dataset, the variable to remove outliers in, and a threshold on the number of SDs away from the mean used to define outliers.

<details>
  <summary>Solution</summary>
  
```{r}
remove_outliers <- function(df, what_var, sd_thresh) {
    df %>% 
        mutate(zscore = ({{ what_var }} - mean({{ what_var}}, na.rm = TRUE))/sd({{ what_var }}, na.rm = TRUE)) %>%
        filter(zscore <= sd_thresh)
}
```

</details>

**Exercise 3:** Write a function that implements the analysis versions specifically for the `diamonds` dataset. The user will not specify the dataset as an argument but will input the model formula and whether or not to remove outliers (cases whose `carat` is over 3 SDs away from the mean).

<details>
  <summary>Solution</summary>
  
```{r}
fit_model <- function(mod_formula, remove_outliers) {
    if (remove_outliers) {
        diamonds_clean <- remove_outliers(diamonds, what_var = carat, sd_thresh = 3)
    } else {
        diamonds_clean <- diamonds
    }
    
    lm(mod_formula, data = diamonds_clean)
}
```

</details>

**Exercise 4:** Write a `for` loop that stores the fitted linear models from all versions of the analysis.

Note that you can pull out the contents of a single data frame column in many ways. For a data frame `df` with a variable named `x`:

- `df$x`
- `df %>% pull(x)`
- `df[["x"]]`

<details>
  <summary>Solution</summary>
  
```{r}
lin_mod_res_for <- vector(mode = "list", length = nrow(df_arg_combos))

for (i in seq_along(lin_mod_res_for)) {
    this_formula <- df_arg_combos$mod_formula[[i]] # Double [[ for the **list** of formulas
    this_remove_outliers <- df_arg_combos$remove_outliers[i] # Single [ for the **atomic vector** of logicals
    lin_mod_res_for[[i]] <- fit_model(
        mod_formula = this_formula,
        remove_outliers = this_remove_outliers
    )
}
```

</details>

**Exercise 5:** Use `pmap()` from `purrr` to replicate what you did with the `for` loop.

<details>
  <summary>Solution</summary>
  
```{r}
lin_mod_res_pmap <- pmap(df_arg_combos, fit_model)
```

</details>



<!--

```{r}
fit_model <- function(df, mod_formula, remove_outliers) {
    if (remove_outliers) {
        df <- remove_outliers(df, what_var = carat, sd_thresh = 3)
    }
    
    lm(mod_formula, data = df)
}

res <- pmap(df_arg_combos, function(remove_outliers, mod_formula) {fit_model(df = diamonds, mod_formula = mod_formula, remove_outliers = remove_outliers)} )
```

```{r}
fit_model <- function(mod_formula, remove_outliers) {
    if (remove_outliers) {
        diamonds_clean <- remove_outliers(diamonds, what_var = carat, sd_thresh = 3)
    } else {
        diamonds_clean <- diamonds
    }
    
    lm(mod_formula, data = diamonds_clean)
}

res <- pmap(df_arg_combos, fit_model)
```

-->

---

**Exercise:** Last class we worked on an extended exercise where our goal was to write a series of functions and a `for` loop to repeat linear model fitting under different "settings" (removal of outliers, model formula choice). Repeat this exercise using `pmap()`--you'll need to use the `df_arg_combos` object, your `remove_outliers()` function, and your `fit_model()` function.

<details>
    <summary>Solution</summary>

```{r pmap_ex_model_variations_soln, eval=FALSE}
pmap(df_arg_combos, fit_model, data = diamonds)
```

</details>

---

3. On the `diamonds` dataset, fit models of price vs. carat separately for each value of `cut`, and store the fitted models in a list storage container.

<details>
    <summary>Solutions</summary>

```{r}
#| label: for-ex-solutions-3
data(diamonds)

# Fit models of price vs. carat separately for each value of cut
unique_cuts <- diamonds %>% 
  pull(cut) %>% 
  levels()

lin_mod_results <- vector(mode = "list", 
                          length = length(unique_cuts)
                          )

for (i in seq_along(unique_cuts)) {
    this_cut <- unique_cuts[i]
    diamonds_sub <- diamonds %>%
        filter(cut == this_cut)
    # The double square brackets [[i]] accesses the ith element of a list
    lin_mod_results[[i]] <- lm(price ~ carat, data = diamonds_sub)
}
```

</details>

