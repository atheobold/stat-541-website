---
title: "Lab 6"
subtitle: "Writing Efficient Code"
editor: source
---

# Writing Functions

## Vector Functions

**Question 1:** The `rescale01()` function below performs a min-max scaling to 
standardize a numeric vector, but infinite values are left unchanged. Rewrite
`rescale01()` so that `-Inf` is mapped to 0, and `Inf` is mapped to 1?
*Hint: This seems like a great place for `case_when()`!

```{r}
#| label: question-1

rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

**Question 2:** Write a function that accepts a vector of birthdates and 
computes the age of each person in years.

```{r}
#| label: question-2

```

**Question 3:** Write a function that computes the variance and skewness of a
numeric vector. Feel free to look up the definitions on Wikipedia or elsewhere!

```{r}
#| label: question-3

```

**Question 4:** Write a function called `both_na()` which takes two vectors of
the same length and returns the number of positions that have an `NA` in both
vectors.

## Data Frame Functions

For Questions 5 - 9 you will write different functions which work with data 
similar to the `nycflights13` data. 

**Question 5:** Write a `filter_severe()` function that finds all flights that
were cancelled (i.e. `is.na(arr_time)`) or delayed by more than an hour.

```{r}
#| label: question-5

```

**Question 6:** Write a `summarize_severe()` function that counts the number of 
cancelled flights and the number of flights delayed by more than an hour.

```{r}
#| label: question-6

```

**Question 7:** Modify your `filter_severe()` function to allow the user to 
supply the number of hours that should be used to filter the flights that were
cancelled or delayed. 

```{r}
#| label: question-7

```

**Question 8:** Write a `summarize_weather()` function that summarizes the
weather to compute the minimum, mean, and maximum, of a user supplied variable. 

```{r}
#| label: question-8

```

**Question 9:** Write a `standardize_time()` function that converts the user
supplied variable that uses clock time (e.g., `dep_time`, `arr_time`, etc.) into
a decimal time (i.e. hours + (minutes / 60)).

```{r}
#| label: question-9

```


## Plotting Functions

Build up a rich plotting function by incrementally implementing each of the steps below:

1.  Draw a scatterplot given dataset and `x` and `y` variables.

2.  Add a line of best fit (i.e. a linear model with no standard errors).

3.  Add a title.

# Iteration

### Saving plots

We can take the same basic approach to create many plots.
Let's first make a function that draws the plot we want:

```{r}
#| fig-alt: |
#|   Histogram of carats of diamonds from the by_clarity dataset, ranging from 
#|   0 to 5 carats. The distribution is unimodal and right skewed with a peak 
#|   around 1 carat.

carat_histogram <- function(df) {
  ggplot(df, aes(x = carat)) + geom_histogram(binwidth = 0.1)  
}

carat_histogram(by_clarity$data[[1]])
```

Now we can use `map()` to create a list of many plots[^iteration-7] and their eventual file paths:

[^iteration-7]: You can print `by_clarity$plot` to get a crude animation --- you'll get one plot for each element of `plots`.
    NOTE: this didn't happen for me.

```{r}
by_clarity <- by_clarity |> 
  mutate(
    plot = map(data, carat_histogram),
    path = str_glue("clarity-{clarity}.png")
  )
```

Then use `walk2()` with `ggsave()` to save each plot:

```{r}
walk2(
  by_clarity$path,
  by_clarity$plot,
  \(path, plot) ggsave(path, plot, width = 6, height = 6)
)
```

This is shorthand for:

```{r}
#| eval: false
ggsave(by_clarity$path[[1]], by_clarity$plot[[1]], width = 6, height = 6)
ggsave(by_clarity$path[[2]], by_clarity$plot[[2]], width = 6, height = 6)
ggsave(by_clarity$path[[3]], by_clarity$plot[[3]], width = 6, height = 6)
...
ggsave(by_clarity$path[[8]], by_clarity$plot[[8]], width = 6, height = 6)
```

```{r}
#| include: false
unlink(by_clarity$path)
```

# Contributing to the R for Data Science Community!

https://github.com/mine-cetinkaya-rundel/r4ds-solutions
